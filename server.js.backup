/**
 * WebHarvest Pro v2.0 - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø«
 */

const http = require('http');
const https = require('https');
const url = require('url');
const fs = require('fs');
const path = require('path');
const zlib = require('zlib');

const PORT = process.env.PORT || 5000;

// Ù…Ø­Ø±Ùƒ Ø§Ù„Ø³Ø­Ø¨
async function fetchUrl(urlStr) {
    return new Promise((resolve, reject) => {
        const client = urlStr.startsWith('https') ? https : http;
        
        const req = client.get(urlStr, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'application/json, text/html, */*',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'ar,en;q=0.9'
            }
        }, (res) => {
            const chunks = [];
            res.on('data', chunk => chunks.push(chunk));
            res.on('end', () => {
                const buffer = Buffer.concat(chunks);
                const encoding = res.headers['content-encoding'];
                
                let data;
                if (encoding === 'br') {
                    data = zlib.brotliDecompressSync(buffer).toString();
                } else if (encoding === 'gzip') {
                    data = zlib.gunzipSync(buffer).toString();
                } else {
                    data = buffer.toString();
                }
                
                resolve({ status: res.statusCode, data, headers: res.headers });
            });
        });
        
        req.setTimeout(15000, () => {
            req.destroy();
            reject(new Error('Timeout'));
        });
        
        req.on('error', reject);
    });
}

// ØªØ­Ù„ÙŠÙ„ JSON
function parseJSON(data, sourceUrl) {
    const products = [];
    const hostname = new URL(sourceUrl).hostname.replace('www.', '');
    
    try {
        const json = JSON.parse(data);
        const items = json.products || json.collection?.products || json.items || [json];
        
        items.forEach(item => {
            if (item.title || item.name || item.product_title) {
                products.push({
                    name: item.title || item.name || item.product_title,
                    price: item.price || item.variants?.[0]?.price || '0',
                    currency: 'EGP',
                    source: hostname,
                    url: sourceUrl
                });
            }
        });
    } catch (e) {}
    
    return products;
}

// ØªØ­Ù„ÙŠÙ„ HTML
function parseHTML(data, sourceUrl) {
    const products = [];
    const hostname = new URL(sourceUrl).hostname.replace('www.', '');
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† Open Graph
    const ogTitle = data.match(/<meta[^>]*property="og:title"[^>]*content="([^"]*)"/i)?.[1];
    const ogPrice = data.match(/<meta[^>]*property="product:price:amount"[^>]*content="([^"]*)"/i)?.[1];
    
    if (ogTitle) {
        products.push({
            name: ogTitle,
            price: ogPrice || '0',
            currency: 'EGP',
            source: hostname,
            url: sourceUrl
        });
    }
    
    return products;
}

// Ø§Ù„Ø®Ø§Ø¯Ù…
const server = http.createServer(async (req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const pathname = parsedUrl.pathname;
    
    // CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }
    
    // Health Check
    if (pathname === '/api/health') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: 'ok', version: '2.0' }));
        return;
    }
    
    // Scrape API
    if (pathname === '/api/scrape') {
        const targetUrl = parsedUrl.query.url;
        
        if (!targetUrl) {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'URL required' }));
            return;
        }
        
        try {
            console.log('ğŸ” Scraping:', targetUrl);
            const { data } = await fetchUrl(targetUrl);
            
            let products = parseJSON(data, targetUrl);
            
            if (products.length === 0) {
                products = parseHTML(data, targetUrl);
            }
            
            console.log('âœ… Found:', products.length, 'products');
            
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ success: true, products, count: products.length }));
        } catch (e) {
            console.error('âŒ Error:', e.message);
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: e.message }));
        }
        return;
    }
    
    // Ù…Ù„ÙØ§Øª Ø«Ø§Ø¨ØªØ©
    let filePath = pathname === '/' ? '/public/index.html' : pathname;
    filePath = path.join(__dirname, filePath);
    
    if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
        const ext = path.extname(filePath);
        const contentTypes = {
            '.html': 'text/html; charset=utf-8',
            '.css': 'text/css; charset=utf-8',
            '.js': 'application/javascript; charset=utf-8',
            '.json': 'application/json; charset=utf-8',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.svg': 'image/svg+xml'
        };
        
        fs.readFile(filePath, (err, data) => {
            if (err) {
                res.writeHead(500);
                res.end('Error');
                return;
            }
            res.setHeader('Content-Type', contentTypes[ext] || 'application/octet-stream');
            res.writeHead(200);
            res.end(data);
        });
        return;
    }
    
    // 404
    res.writeHead(404);
    res.end('Not found');
});

server.listen(PORT, () => {
    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘   ğŸš€ WebHarvest Pro v2.0                             â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘   Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰: http://localhost:' + PORT + '          â•‘');
    console.log('â•‘   âœ… ÙˆØ§Ø¬Ù‡Ø© ÙˆÙŠØ¨ + ØªØµØ¯ÙŠØ± Excel + Sale Zone             â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
});

module.exports = server;
